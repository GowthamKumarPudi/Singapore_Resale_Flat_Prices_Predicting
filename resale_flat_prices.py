# -*- coding: utf-8 -*-
"""Resale_Flat_Prices.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EXLdiimTdSWO5qAbro8lHDu6WwBQsROM

## Resale Flat Prices
"""

# Packages

import pandas as pd
import numpy as np
import warnings
warnings.filterwarnings("ignore")
from datetime import datetime
import plotly as px
import seaborn as sns
import matplotlib.pyplot as plt

#Encoding packages

from sklearn.preprocessing import LabelEncoder,OrdinalEncoder

"""# *Reading the "csv" files (Registration)*"""

# reading the 2012 to 2014
df_1= pd.read_csv(r"/content/Resale Flat Prices (Based on Registration Date), From Mar 2012 to Dec 2014.csv")
df_1.head(2)

# reading the 2015 to 2016
df_2= pd.read_csv(r"/content/Resale Flat Prices (Based on Registration Date), From Jan 2015 to Dec 2016.csv")
df_2.tail(2)

# reading the 2017 to onwards
df_3= pd.read_csv(r"/content/Resale flat prices based on registration date from Jan-2017 onwards.csv")
df_3.head(2)

"""## Preprocessing"""

#df_1 does not have a "remaining_lease" column so, I choose the df_2 and df_3 only

#concadinating the df_2 and df_3

df_4= pd.concat([df_2,df_3],axis= 0)
df_4.reset_index(drop= True, inplace= True)
df_4.tail(2)

df_4.info()

df_4.isnull().sum()

# This Dataset have not any null values

"""## Encoding the catogarical columns and
## chaning the datatype
"""

df_4.head(2)

# Creating a new column "address"
df_4["address"]= df_4["block"]+" "+df_4["street_name"]

#droping the "street_name" and "block"
df_5= df_4.drop(columns=["block","street_name"])

df_5.head(2)

# for month
df_5["month"] = pd.to_datetime(df_5["month"], format="%Y-%m")

#spliting the month column to "Year", "month", "day"
df_5["year"]= df_5["month"].dt.year
df_5["month"]= df_5["month"].dt.month

df_5.head(2)

df_5["town"].unique()

df_5["town"].nunique()

df_5["flat_type"].unique()

df_5["flat_type"].nunique()

df_5["flat_model"].unique()

df_5["flat_model"].nunique()

# choosing the "LabelEncoder" for "town",and "OrdinalEncoder" for the "flat_model" and the "flat_type"
df_5["town"]= LabelEncoder().fit_transform(df_5["town"])
df_5["flat_model"]= OrdinalEncoder().fit_transform(df_5[["flat_model"]])
df_5["flat_type"]= OrdinalEncoder().fit_transform(df_5[["flat_type"]])

df_5["town"].unique()

df_5["flat_type"].unique()

df_5["flat_model"].unique()

df_5.tail(2)

df_5[["storey_start", "storey_end"]]= df_5["storey_range"].str.split(" TO ",expand=True)

#droping the "storey_range" column
df_5.drop(columns=["storey_range"],inplace= True)

df_5.head(2)

df_5["address"].nunique()

# Address have 9559 unique values in the 207823 , so i encode it for the correlation checking
# I chooshing the "LabelEncoder" for the "address" column

df_5["address"]= LabelEncoder().fit_transform(df_5["address"])

df_5["storey_start"]= df_5["storey_start"].astype(int)
df_5["storey_end"]= df_5["storey_end"].astype(int)

# "remaining_lease" have a "60 years 8 months" this type of data ,
# so we want to split the year and month separately for the correlation checking
slice_values= []
for i in df_5["remaining_lease"].astype(str):
    j= i.replace("years","")
    k= j.replace("months","")
    l= k.replace("month","")
    m= l.strip()
    n= m.split("  ")
    slice_values.append(n)

df_data= pd.DataFrame(slice_values,columns=["remaining_lease_year", "remaining_lease_month"])

df_data["remaining_lease_year"]= df_data["remaining_lease_year"].astype(int)
df_data["remaining_lease_month"]= df_data["remaining_lease_month"].fillna(0).astype(int)

#droping the "remaining_lease" column
df_5.drop(columns=["remaining_lease"],inplace= True)

df_6= pd.concat([df_5,df_data],axis=1)

df_6.columns

# set the columns
df_7= df_6[['year','month', 'town', 'flat_type', 'floor_area_sqm', 'flat_model', 'address',
       'storey_start', 'storey_end', 'remaining_lease_year','remaining_lease_month',
       'lease_commence_date', 'resale_price']]

df_8=df_7.sort_values(by=["year","month"])

df_8.to_csv("ResaleFlatPrices.csv", index= False)

# Checking the Correlation using heatmap

df_8_corr= df_8.corr()
plt.figure(figsize=(10,5))
sns.heatmap(df_8_corr,annot= True, cmap="Greens", fmt=".2f")
plt.show()

df_final= pd.read_csv(r"/content/ResaleFlatPrices.csv")
df_final.head(2)

# checking the duplicate values
df_final.duplicated().sum()

df_final_1= df_final.drop_duplicates()
df_final_1.reset_index(drop= True, inplace= True)

df_final_1.tail(2)

# The month,address column does have very lowest correlation with other features
# So I drop the month and address columns

df_final_2= df_final_1.drop(columns=["month","address"])

df_final_2.tail(2)

# detecting the skewed columns using plot
def plot(df,column):
  #distplot
  plt.figure(figsize=(15,4))
  plt.subplot(1,3,1)
  sns.distplot(df[column])
  plt.title("distplot for"+" "+column)

  #histogram plot

  plt.subplot(1,3,2)
  sns.histplot(df, x= column, kde= True, bins=30,color="salmon")
  plt.title("histogram plot for"+" "+column)

  #boxplot

  plt.subplot(1,3,3)

  sns.boxplot(df, x=column)
  plt.title("Box plot for"+" "+column)

for i in df_final_2.columns:
    plot(df_final_2,i)

df_final_2.describe().T

"""## skewness handling"""

df_final_3= df_final_2.copy()

# The Skewness Columns are
# 2. storey_start
# 3. storey_end
# 4. resale_price

df_final_3["storey_start"]= np.log(df_final_3["storey_start"])
df_final_3["storey_end"]= np.log(df_final_3["storey_end"])
df_final_3["resale_price"]= np.log(df_final_3["resale_price"])

skewed_columns=["storey_start","storey_end","resale_price"]
for i in skewed_columns:
    plot(df_final_3,i)

"""## Outliers Handling - Interquartile Range(IQR) Method"""

df_final_4= df_final_3.copy()

# The Outlier Columns are
# 1. floor_area_sqm
# 2. storey_start
# 3. sortey_end
# 4. resale_price
# Recorrect the Outliers

# (Ex: lower threshold = 5 and upper threshold = 20)
# above upper threshold values (>20) are converted to upper threshold value (20) in features
# below lower threshold values (<5)  are converted to lower threshold value (5)  in features

def outlier(df,column):
  q1= df[column].quantile(0.25)
  q3= df[column].quantile(0.75)

  iqr= q3-q1

  upper_threshold= q3 + (1.5*iqr)
  lower_threshold= q1 - (1.5*iqr)

  df[column]= df[column].clip(lower_threshold, upper_threshold)

outlier_columns=["floor_area_sqm","storey_start","storey_end","resale_price"]
for j in outlier_columns:
    outlier(df_final_4,j)

for k in outlier_columns:
    plot(df_final_4,k)

# Checking the correlation after the outlier recorrection
plt.figure(figsize=(10,5))
sns.heatmap(df_final_4.corr(), annot= True, cmap="Greens", fmt="0.2f")
plt.show()

"""## Model Selection (Regression)"""

df_final_5= df_final_4.copy()

df_final_5.describe().T

np.exp(13.942690)

#checking how many datas are outliers based on resale_price
df_final_1[df_final_1["resale_price"] >= 1135620]

np.exp(12.104561)

#checking how many datas are outliers based on resale_price
df_final_1[df_final_1["resale_price"] <= 180694]

# now we want to create the model for "resale_price" prediction
# importing the model
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score,mean_squared_error,mean_absolute_error
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.ensemble import AdaBoostRegressor
from sklearn.ensemble import ExtraTreesRegressor
from sklearn.ensemble import GradientBoostingRegressor
from xgboost import XGBRegressor
import pickle

# Train Test Split for model selection
def select_model(df, algorithm):
    # x, y spliting
    x= df.drop(columns=["resale_price"])
    y= df["resale_price"]

    X_train, X_test, y_train, y_test= train_test_split(x,y, test_size=0.2, random_state=42)

    model= algorithm().fit(X_train,y_train)
    y_pred_train= model.predict(X_train)
    y_pred_test= model.predict(X_test)

    #Checking the accuracy score
    train_mse= mean_squared_error(y_train, y_pred_train)
    train_rmse= np.sqrt(train_mse)
    train_mae= mean_absolute_error(y_train, y_pred_train)
    train_r2= r2_score(y_train, y_pred_train)

    test_mse= mean_squared_error(y_test, y_pred_test)
    test_rmse= np.sqrt(test_mse)
    test_mae= mean_absolute_error(y_test, y_pred_test)
    test_r2= r2_score(y_test, y_pred_test)

    metrics_train={"Data": "Train Data",
        "Name":algorithm.__name__,
        "R2_score":train_r2,
        "Mean_squared_error":train_mse,
        "Root_mean_squared_error":train_rmse,
        "Mean_absolute_error":train_mae
        }

    metrics_test={"Data": "Test Data",
           "Name":algorithm.__name__,
           "R2_score":test_r2,
           "Mean_squared_error":test_mse,
           "Root_mean_squared_error":test_rmse,
           "Mean_absolute_error":test_mae
              }

    print(metrics_train)
    print(metrics_test)
    print("")

select_model(df_final_5, LinearRegression)
select_model(df_final_5, DecisionTreeRegressor)
select_model(df_final_5, RandomForestRegressor)
select_model(df_final_5, AdaBoostRegressor)
select_model(df_final_5, ExtraTreesRegressor)
select_model(df_final_5, GradientBoostingRegressor)
select_model(df_final_5, XGBRegressor)

# RandomForestClassifier is good interpretability,
# And it will detect the unseen data for this datas (without overfitting)
# so i select the algorithm

#x,y spliting
x= df_final_5.drop(columns=["resale_price"])
y= df_final_5["resale_price"]

X_train, X_test, y_train, y_test= train_test_split(x,y, test_size=0.2, random_state=42)

model_1= RandomForestRegressor().fit(X_train,y_train)
y_pred= model_1.predict(X_test)

test_mse= mean_squared_error(y_test, y_pred)
test_rmse= np.sqrt(test_mse)
test_mae= mean_absolute_error(y_test, y_pred)
test_r2= r2_score(y_test, y_pred)

metrics_test={"Data": "Test Data",
        "Name":RandomForestRegressor.__name__,
        "R2_score":test_r2,
        "Mean_squared_error":test_mse,
        "Root_mean_squared_error":test_rmse,
        "Mean_absolute_error":test_mae
            }

print(metrics_test)

df_final_5.iloc[10456]

np.exp(12.815838)

user_data = np.array([[2015,4,2,74,8,0.011858,1.098612,68,0,1985]])
y_pred_1 = model_1.predict(user_data)
y_pred_1[0]

np.exp(12.792003979535888)

# Saving the Model unsing pickle
with open("Resale_Flat_Prices_Model_1.pkl","wb") as f:
  pickle.dump(model_1,f)

import pickle
import numpy as np

with open("Resale_Flat_Prices_Model_1.pkl","rb") as f1:
    regg_model= pickle.load(f1)

user_data = np.array([[2015,8,5,4.955827,3,1.386294,1.791759,73,0,1990]])
y_pred_1 = regg_model.predict(user_data)
y_pred_1[0]

np.exp(12.313923357750493)

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# 
# # Packages
# 
# import pandas as pd
# import numpy as np
# import warnings
# warnings.filterwarnings("ignore")
# from datetime import datetime
# import streamlit as st
# from streamlit_option_menu import option_menu
# import pickle
# from PIL import Image
# 
# def town_mapping(town_map):
#     if town_map == 'ANG MO KIO':
#         town_1 = int(0)
#     elif town_map == 'BEDOK':
#         town_1 = int(1)
#     elif town_map == 'BISHAN':
#         town_1= int(2)
#     elif town_map == 'BUKIT BATOK':
#         town_1= int(3)
#     elif town_map == 'BUKIT MERAH':
#         town_1= int(4)
#     elif town_map == 'BUKIT PANJANG':
#         town_1= int(5)
# 
#     elif town_map == 'BUKIT TIMAH':
#         town_1= int(6)
#     elif town_map == 'CENTRAL AREA':
#         town_1= int(7)
#     elif town_map == 'CHOA CHU KANG':
#         town_1= int(8)
#     elif town_map == 'CLEMENTI':
#         town_1= int(9)
#     elif town_map == 'GEYLANG':
#         town_1= int(10)
# 
#     elif town_map == 'HOUGANG':
#         town_1 = int(11)
#     elif town_map == 'JURONG EAST':
#         town_1= int(12)
#     elif town_map == 'JURONG WEST':
#         town_1= int(13)
#     elif town_map == 'KALLANG/WHAMPOA':
#         town_1= int(14)
#     elif town_map == 'MARINE PARADE':
#         town_1= int(15)
# 
#     elif town == 'PASIR RIS':
#         town_1= int(16)
#     elif town == 'PUNGGOL':
#         town_1= int(17)
#     elif town == 'QUEENSTOWN':
#         town_1= int(18)
#     elif town == 'SEMBAWANG':
#         town_1= int(19)
#     elif town == 'SENGKANG':
#         town_1= int(20)
# 
#     elif town == 'SERANGOON':
#         town_1= int(21)
#     elif town == 'TAMPINES':
#         town_1= int(22)
#     elif town == 'TOA PAYOH':
#         town_1= int(23)
#     elif town == 'WOODLANDS':
#         town_1= int(24)
#     elif town == 'YISHUN':
#         town_1= int(25)
# 
#     return town_1
# 
# def flat_type_mapping(flt_type):
# 
#     if flt_type == '3 ROOM':
#         flat_type_1= int(2)
#     elif flt_type == '4 ROOM':
#         flat_type_1= int(3)
#     elif flt_type == '5 ROOM':
#         flat_type_1= int(4)
#     elif flt_type == '2 ROOM':
#         flat_type_1= int(1)
#     elif flt_type == 'EXECUTIVE':
#         flat_type_1= int(5)
#     elif flt_type == '1 ROOM':
#         flat_type_1= int(0)
#     elif flt_type == 'MULTI-GENERATION':
#         flat_type_1= int(6)
# 
#     return flat_type_1
# 
# def flat_model_mapping(fl_m):
# 
#     if fl_m == 'Improved':
#         flat_model_1= int(5)
#     elif fl_m == 'New Generation':
#         flat_model_1= int(12)
# 
#     elif fl_m == 'Model A':
#         flat_model_1= int(8)
#     elif fl_m == 'Standard':
#         flat_model_1= int(17)
#     elif fl_m == 'Simplified':
#         flat_model_1= int(16)
#     elif fl_m == 'Premium Apartment':
#         flat_model_1= int(13)
#     elif fl_m == 'Maisonette':
#         flat_model_1= int(7)
# 
#     elif fl_m == 'Apartment':
#         flat_model_1= int(3)
#     elif fl_m == 'Model A2':
#         flat_model_1= int(10)
#     elif fl_m == 'Type S1':
#         flat_model_1= int(19)
#     elif fl_m == 'Type S2':
#         flat_model_1= int(20)
#     elif fl_m == 'Adjoined flat':
#         flat_model_1= int(2)
# 
#     elif fl_m == 'Terrace':
#         flat_model_1= int(18)
#     elif fl_m == 'DBSS':
#         flat_model_1= int(4)
#     elif fl_m == 'Model A-Maisonette':
#         flat_model_1= int(9)
#     elif fl_m == 'Premium Maisonette':
#         flat_model_1= int(15)
#     elif fl_m == 'Multi Generation':
#         flat_model_1= int(11)
# 
#     elif fl_m == 'Premium Apartment Loft':
#         flat_model_1= int(14)
#     elif fl_m == 'Improved-Maisonette':
#         flat_model_1= int(6)
#     elif fl_m == '2-room':
#         flat_model_1= int(0)
#     elif fl_m == '3Gen':
#         flat_model_1= int(1)
# 
#     return flat_model_1
# 
# 
# def predict_price(year,town,flat_type,flr_area_sqm,flat_model,stry_start,stry_end,re_les_year,
#               re_les_month,les_coms_dt):
# 
#     year_1= int(year)
#     town_2= town_mapping(town)
#     flt_ty_2= flat_type_mapping(flat_type)
#     flr_ar_sqm_1= int(flr_area_sqm)
#     flt_model_2= flat_model_mapping(flat_model)
#     str_str= np.log(int(stry_start))
#     str_end= np.log(int(stry_end))
#     rem_les_year= int(re_les_year)
#     rem_les_month= int(re_les_month)
#     lese_coms_dt= int(les_coms_dt)
# 
# 
#     with open(r"Resale_Flat_Prices_Model_1.pkl","rb") as f:
#         regg_model= pickle.load(f)
# 
#     user_data = np.array([[year_1,town_2,flt_ty_2,flr_ar_sqm_1,
#                            flt_model_2,str_str,str_end,rem_les_year,rem_les_month,
#                            lese_coms_dt]])
#     y_pred_1 = regg_model.predict(user_data)
#     price= np.exp(y_pred_1[0])
# 
#     return round(price)
# 
# 
# 
# st.set_page_config(layout="wide")
# 
# st.title("SINGAPORE RESALE FLAT PRICES PREDICTING")
# st.write("")
# 
# with st.sidebar:
#     select= option_menu("MAIN MENU",["Home", "Price Prediction", "About"])
# 
# if select == "Home":
#     img= Image.open(r"/content/536449975M-1733679601790.jpg")
#     st.image(img)
# 
#     st.header("HDB Flats:")
# 
#     st.write('''The majority of Singaporeans live in public housing provided by the HDB.
#     HDB flats can be purchased either directly from the HDB as a new unit or through the resale market from existing owners.''')
# 
#     st.header("Resale Process:")
# 
#     st.write('''In the resale market, buyers purchase flats from existing flat owners, and the transactions are facilitated through the HDB resale process.
#     The process involves a series of steps, including valuation, negotiations, and the submission of necessary documents.''')
# 
#     st.header("Valuation:")
# 
#     st.write('''The HDB conducts a valuation of the flat to determine its market value. This is important for both buyers and sellers in negotiating a fair price.''')
# 
#     st.header("Eligibility Criteria:")
# 
#     st.write("Buyers and sellers in the resale market must meet certain eligibility criteria, including citizenship requirements and income ceilings.")
# 
#     st.header("Resale Levy:")
# 
#     st.write("For buyers who have previously purchased a subsidized flat from the HDB, there might be a resale levy imposed when they purchase another flat from the HDB resale market.")
# 
#     st.header("Grant Schemes:")
# 
#     st.write("There are various housing grant schemes available to eligible buyers, such as the CPF Housing Grant, which provides financial assistance for the purchase of resale flats.")
# 
#     st.header("HDB Loan and Bank Loan:")
# 
#     st.write("Buyers can choose to finance their flat purchase through an HDB loan or a bank loan. HDB loans are provided by the HDB, while bank loans are obtained from commercial banks.")
# 
#     st.header("Market Trends:")
# 
#     st.write("The resale market is influenced by various factors such as economic conditions, interest rates, and government policies. Property prices in Singapore can fluctuate based on these factors.")
# 
#     st.header("Online Platforms:")
# 
#     st.write("There are online platforms and portals where sellers can list their resale flats, and buyers can browse available options.")
# 
# elif select == "Price Prediction":
# 
#     col1,col2= st.columns(2)
#     with col1:
# 
#         year= st.selectbox("Select the Year",["2015", "2016", "2017", "2018", "2019", "2020", "2021",
#                            "2022", "2023", "2024"])
# 
#         town= st.selectbox("Select the Town", ['ANG MO KIO', 'BEDOK', 'BISHAN', 'BUKIT BATOK', 'BUKIT MERAH',
#                                             'BUKIT PANJANG', 'BUKIT TIMAH', 'CENTRAL AREA', 'CHOA CHU KANG',
#                                             'CLEMENTI', 'GEYLANG', 'HOUGANG', 'JURONG EAST', 'JURONG WEST',
#                                             'KALLANG/WHAMPOA', 'MARINE PARADE', 'PASIR RIS', 'PUNGGOL',
#                                             'QUEENSTOWN', 'SEMBAWANG', 'SENGKANG', 'SERANGOON', 'TAMPINES',
#                                             'TOA PAYOH', 'WOODLANDS', 'YISHUN'])
# 
#         flat_type= st.selectbox("Select the Flat Type", ['3 ROOM', '4 ROOM', '5 ROOM', '2 ROOM', 'EXECUTIVE', '1 ROOM',
#                                                         'MULTI-GENERATION'])
# 
#         flr_area_sqm= st.number_input("Enter the Value of Floor Area sqm (Min: 31 / Max: 280")
# 
#         flat_model= st.selectbox("Select the Flat Model", ['Improved', 'New Generation', 'Model A', 'Standard', 'Simplified',
#                                                         'Premium Apartment', 'Maisonette', 'Apartment', 'Model A2',
#                                                         'Type S1', 'Type S2', 'Adjoined flat', 'Terrace', 'DBSS',
#                                                         'Model A-Maisonette', 'Premium Maisonette', 'Multi Generation',
#                                                         'Premium Apartment Loft', 'Improved-Maisonette', '2-room', '3Gen'])
# 
#     with col2:
# 
#         stry_start= st.number_input("Enter the Value of Storey Start")
# 
#         stry_end= st.number_input("Enter the Value of Storey End")
# 
#         re_les_year= st.number_input("Enter the Value of Remaining Lease Year (Min: 42 / Max: 97)")
# 
#         re_les_month= st.number_input("Enter the Value of Remaining Lease Month (Min: 0 / Max: 11)")
# 
#         les_coms_dt= st.selectbox("Select the Lease_Commence_Date", [str(i) for i in range(1966,2023)])
# 
#     button= st.button("Predict the Price", use_container_width= True)
# 
#     if button:
# 
# 
#         pre_price= predict_price(year, town, flat_type, flr_area_sqm, flat_model,
#                         stry_start, stry_end, re_les_year, re_les_month, les_coms_dt)
# 
#         st.write("## :green[**The Predicted Price is :**]",pre_price)
# 
# 
# elif select == "About":
# 
#     st.header(":blue[Data Collection and Preprocessing:]")
#     st.write("Collect a dataset of resale flat transactions from the Singapore Housing and Development Board (HDB) for the years 1990 to Till Date. Preprocess the data to clean and structure it for machine learning.")
# 
#     st.header(":blue[Feature Engineering:]")
#     st.write("Extract relevant features from the dataset, including town, flat type, storey range, floor area, flat model, and lease commence date. Create any additional features that may enhance prediction accuracy.")
# 
#     st.header(":blue[Model Selection and Training:]")
#     st.write("Choose an appropriate machine learning model for regression (e.g., linear regression, decision trees, or random forests). Train the model on the historical data, using a portion of the dataset for training.")
# 
#     st.header(":blue[Model Evaluation:]")
#     st.write("Evaluate the model's predictive performance using regression metrics such as Mean Absolute Error (MAE), Mean Squared Error (MSE), or Root Mean Squared Error (RMSE) and R2 Score.")
# 
#     st.header(":blue[Streamlit Web Application:]")
#     st.write("Develop a user-friendly web application using Streamlit that allows users to input details of a flat (town, flat type, storey range, etc.). Utilize the trained machine learning model to predict the resale price based on user inputs.")
# 
#     st.header(":blue[Deployment on Render:]")
#     st.write("Deploy the Streamlit application on the Render platform to make it accessible to users over the internet.")
# 
#     st.header(":blue[Testing and Validation:]")
#     st.write("Thoroughly test the deployed application to ensure it functions correctly and provides accurate predictions.")
#

!wget -q -O - ipv4.icanhazip.com

!npm install localtunnel

!npm audit fix --force

! streamlit run app.py & npx localtunnel --port 8501

!pip install Streamlit
!pip install streamlit_option_menu

!pip install streamlit-aggrid

!pip install --upgrade streamlit streamlit-option-menu

!streamlit cache clear